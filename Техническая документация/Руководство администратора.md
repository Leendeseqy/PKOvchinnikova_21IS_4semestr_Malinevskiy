# Руководство администратора
## Локальный мессенджер для образовательных учреждений

**Разработчик:** Малиневский Егор Сергеевич/21ИС-24  
**Версия руководства:** 1.2  
**Дата создания:** 2024  
**Статус:** Для служебного пользования

---

## 1. Введение

### 1.1. Назначение документа
Настоящее руководство предназначено для системных администраторов и технических специалистов, ответственных за установку, настройку и обслуживание серверной части локального мессенджера в образовательных учреждениях.

### 1.2. Обзор системы
Локальный мессенджер - это клиент-серверное приложение для обмена сообщениями в пределах локальной сети без необходимости подключения к интернету. Система состоит из:
- **Серверной части:** FastAPI приложение с базой данных SQLite
- **Клиентской части:** Приложение на PyQt5 для Windows/Linux

### 1.3. Требования к администратору
- Базовые знания работы с командной строкой
- Понимание принципов работы локальных сетей
- Навыки работы с базами данных SQLite
- Знакомство с Python (рекомендуется)

---

## 2. Установка и настройка сервера

### 2.1. Предварительные требования

#### 2.1.1. Аппаратные требования
| Компонент | Минимальные требования | Рекомендуемые требования |
|-----------|------------------------|---------------------------|
| Процессор | 1 ядро, 1 ГГц | 2 ядра, 2 ГГц+ |
| Оперативная память | 512 МБ | 2 ГБ |
| Дисковое пространство | 100 МБ | 1 ГБ+ |
| Сетевая карта | 100 Мбит/с | 1 Гбит/с |

#### 2.1.2. Программные требования
- **Операционная система:** Windows 10/11, Linux (Ubuntu 20.04+), macOS
- **Python:** версия 3.8 или выше
- **Доступ к сети:** Статический IP адрес в локальной сети
- **Порты:** Открытый порт 8000/TCP

### 2.2. Установка на Windows

#### 2.2.1. Установка Python
1. Скачайте Python 3.8+ с [официального сайта](https://python.org)
2. Запустите установщик
3. **ВАЖНО:** Отметьте галочку "Add Python to PATH"
4. Завершите установку

#### 2.2.2. Установка сервера
```batch
:: Шаг 1: Создание рабочей директории
mkdir C:\LMessenger
cd C:\LMessenger

:: Шаг 2: Копирование файлов сервера
xcopy /E /I "\\путь_к_файлам\server" "C:\LMessenger\server"

:: Шаг 3: Создание виртуального окружения
python -m venv venv

:: Шаг 4: Активация виртуального окружения
venv\Scripts\activate

:: Шаг 5: Установка зависимостей
pip install -r server\requirements.txt

:: Шаг 6: Настройка конфигурации
copy server\config.example.py server\config.py
:: Отредактируйте config.py, указав IP сервера
```

#### 2.2.3. Файл конфигурации сервера
```python
# config.py
SERVER_HOST = "192.168.0.100"  # IP адрес сервера
SERVER_PORT = 8000
SERVER_URL = f"http://{SERVER_HOST}:{SERVER_PORT}"

# Настройки безопасности
SECRET_KEY = "your-secret-key-here-change-in-production"
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 1440  # 24 часа

# Настройки базы данных
DATABASE_URL = "sqlite:///./messenger.db"

# Настройки файлов
MAX_FILE_SIZE_MB = 10
ALLOWED_IMAGE_TYPES = [".png", ".jpg", ".jpeg", ".gif", ".bmp"]
```

### 2.3. Установка на Linux (Ubuntu/Debian)

#### 2.3.1. Установка зависимостей
```bash
#!/bin/bash
# install_server.sh

# Обновление системы
sudo apt update && sudo apt upgrade -y

# Установка Python и необходимых пакетов
sudo apt install python3 python3-pip python3-venv -y

# Создание пользователя для сервера
sudo useradd -m -s /bin/bash lmessenger
sudo usermod -aG sudo lmessenger

# Копирование файлов сервера
sudo mkdir -p /opt/lmessenger
sudo chown -R lmessenger:lmessenger /opt/lmessenger

# Переключение на пользователя lmessenger
sudo su - lmessenger
cd /opt/lmessenger
```

#### 2.3.2. Настройка сервера
```bash
# Клонирование или копирование файлов сервера
git clone https://github.com/your-repo/local-messenger.git
# ИЛИ
cp -r /путь/к/серверу/* .

# Создание виртуального окружения
python3 -m venv venv
source venv/bin/activate

# Установка зависимостей
pip install -r requirements.txt

# Настройка конфигурации
cp config.example.py config.py
nano config.py  # Редактирование конфигурации
```

### 2.4. Запуск сервера

#### 2.4.1. Ручной запуск
```bash
# В Windows (из командной строки)
cd C:\LMessenger\server
venv\Scripts\activate
python main.py

# В Linux
cd /opt/lmessenger
source venv/bin/activate
python main.py
```

#### 2.4.2. Запуск как службы

**Для Windows (служба):**
```batch
:: Создание службы Windows
sc create LMessengerService binPath= "C:\LMessenger\server\venv\Scripts\python.exe C:\LMessenger\server\main.py" start= auto
sc description LMessengerService "Local Messenger Server Service"
net start LMessengerService
```

**Для Linux (systemd):**
```bash
# Создание файла службы
sudo nano /etc/systemd/system/lmessenger.service
```

```ini
[Unit]
Description=Local Messenger Server
After=network.target

[Service]
Type=simple
User=lmessenger
WorkingDirectory=/opt/lmessenger
Environment="PATH=/opt/lmessenger/venv/bin"
ExecStart=/opt/lmessenger/venv/bin/python main.py
Restart=on-failure
RestartSec=5

[Install]
WantedBy=multi-user.target
```

```bash
# Запуск службы
sudo systemctl daemon-reload
sudo systemctl enable lmessenger
sudo systemctl start lmessenger
sudo systemctl status lmessenger
```

#### 2.4.3. Проверка работоспособности
```bash
# Проверка доступности сервера
curl http://localhost:8000/docs
# или в браузере: http://ваш-ip:8000/docs

# Проверка логов
# Windows
type server.log
# Linux
tail -f /opt/lmessenger/server.log
```

### 2.5. Настройка сети

#### 2.5.1. Настройка статического IP
```bash
# Linux (Ubuntu)
sudo nano /etc/netplan/01-netcfg.yaml
```

```yaml
network:
  version: 2
  ethernets:
    eth0:
      addresses:
        - 192.168.0.100/24
      gateway4: 192.168.0.1
      nameservers:
        addresses: [8.8.8.8, 8.8.4.4]
```

```bash
sudo netplan apply
```

#### 2.5.2. Настройка брандмауэра
```bash
# Linux (UFW)
sudo ufw allow 8000/tcp
sudo ufw enable

# Windows Firewall
netsh advfirewall firewall add rule name="LMessenger Server" dir=in action=allow protocol=TCP localport=8000
```

### 2.6. Массовая установка клиентов

#### 2.6.1. Сценарий установки для компьютерного класса
```batch
:: deploy_clients.bat - для Windows
@echo off
echo Установка Local Messenger на компьютеры класса...

for /f %%i in (computers.txt) do (
    echo Установка на компьютер: %%i
    xcopy /E /I "\\server\share\lmessenger_client" "\\%%i\C$\Program Files\LMessenger"
    
    :: Создание ярлыка на рабочем столе
    echo [InternetShortcut] > "\\%%i\C$\Users\Public\Desktop\LMessenger.url"
    echo URL=file:///C:/Program Files/LMessenger/main.exe >> "\\%%i\C$\Users\Public\Desktop\LMessenger.url"
    
    :: Настройка автозапуска
    reg add "\\%%i\HKLM\Software\Microsoft\Windows\CurrentVersion\Run" /v LMessenger /t REG_SZ /d "C:\Program Files\LMessenger\main.exe" /f
)

echo Установка завершена!
pause
```

#### 2.6.2. Файл конфигурации клиентов
```python
# config.py для клиентов
SERVER_HOST = "192.168.0.100"  # IP сервера
SERVER_PORT = 8000
SERVER_URL = f"http://{SERVER_HOST}:{SERVER_PORT}"

# Настройки клиента
AUTO_START = True
NOTIFICATIONS = True
SAVE_PASSWORD = False
THEME = "light"  # light/dark
```

---

## 3. Конфигурация базы данных

### 3.1. Структура базы данных

#### 3.1.1. Основные таблицы
```sql
-- Таблица пользователей
CREATE TABLE IF NOT EXISTS users (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    username TEXT UNIQUE NOT NULL,
    password_hash TEXT NOT NULL,
    is_online BOOLEAN DEFAULT FALSE,
    last_seen DATETIME,
    status TEXT DEFAULT 'offline',
    is_admin BOOLEAN DEFAULT FALSE,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- Таблица сообщений
CREATE TABLE IF NOT EXISTS messages (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    sender_id INTEGER NOT NULL,
    receiver_id INTEGER NOT NULL,
    content TEXT NOT NULL,
    message_type TEXT DEFAULT 'text',
    file_data TEXT,
    is_read BOOLEAN DEFAULT FALSE,
    timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (sender_id) REFERENCES users (id) ON DELETE CASCADE,
    FOREIGN KEY (receiver_id) REFERENCES users (id) ON DELETE CASCADE
);
```

#### 3.1.2. Индексы для оптимизации
```sql
-- Для быстрого поиска пользователей
CREATE INDEX IF NOT EXISTS idx_users_username ON users(username);
CREATE INDEX IF NOT EXISTS idx_users_online ON users(is_online);

-- Для поиска сообщений
CREATE INDEX IF NOT EXISTS idx_messages_sender_receiver ON messages(sender_id, receiver_id);
CREATE INDEX IF NOT EXISTS idx_messages_timestamp ON messages(timestamp DESC);
CREATE INDEX IF NOT EXISTS idx_messages_unread ON messages(receiver_id, is_read) WHERE is_read = FALSE;
```

### 3.2. Инициализация базы данных

#### 3.2.1. Первоначальная настройка
```python
# init_database.py
import sqlite3
from pathlib import Path

def init_database():
    db_path = Path("messenger.db")
    
    if db_path.exists():
        print("База данных уже существует.")
        return
    
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()
    
    # Создание таблиц
    cursor.execute("""
        CREATE TABLE users (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            username TEXT UNIQUE NOT NULL,
            password_hash TEXT NOT NULL,
            is_online BOOLEAN DEFAULT FALSE,
            last_seen DATETIME,
            status TEXT DEFAULT 'offline',
            is_admin BOOLEAN DEFAULT FALSE,
            created_at DATETIME DEFAULT CURRENT_TIMESTAMP
        )
    """)
    
    cursor.execute("""
        CREATE TABLE messages (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            sender_id INTEGER NOT NULL,
            receiver_id INTEGER NOT NULL,
            content TEXT NOT NULL,
            message_type TEXT DEFAULT 'text',
            file_data TEXT,
            is_read BOOLEAN DEFAULT FALSE,
            timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (sender_id) REFERENCES users (id),
            FOREIGN KEY (receiver_id) REFERENCES users (id)
        )
    """)
    
    # Создание индексов
    cursor.execute("CREATE INDEX idx_users_username ON users(username)")
    cursor.execute("CREATE INDEX idx_messages_sender_receiver ON messages(sender_id, receiver_id)")
    
    conn.commit()
    conn.close()
    
    print("База данных успешно инициализирована.")

if __name__ == "__main__":
    init_database()
```

#### 3.2.2. Создание администратора
```bash
# Создание администратора через API
curl -X POST http://localhost:8000/auth/register \
  -H "Content-Type: application/json" \
  -d '{"username":"admin","password":"AdminPass123"}'

# Или через SQL
sqlite3 messenger.db
INSERT INTO users (username, password_hash, is_admin) 
VALUES ('admin', '$2b$12$...хеш...', 1);
```

### 3.3. Администрирование базы данных

#### 3.3.1. Основные команды SQLite
```bash
# Подключение к базе данных
sqlite3 messenger.db

# Просмотр таблиц
.tables

# Просмотр структуры таблицы
.schema users

# Выполнение SQL запроса
SELECT * FROM users;

# Экспорт данных
.output users_backup.sql
.dump users
.output stdout

# Импорт данных
.read backup.sql

# Выход
.quit
```

#### 3.3.2. Полезные SQL запросы для администрирования

**Статистика системы:**
```sql
-- Количество пользователей
SELECT COUNT(*) as total_users FROM users;

-- Количество сообщений
SELECT COUNT(*) as total_messages FROM messages;

-- Количество онлайн пользователей
SELECT COUNT(*) as online_users FROM users WHERE is_online = TRUE;

-- Размер базы данных (в МБ)
SELECT page_count * page_size / 1024 / 1024 as size_mb 
FROM pragma_page_count(), pragma_page_size();

-- Самые активные пользователи
SELECT 
    u.username,
    COUNT(m.id) as message_count
FROM users u
LEFT JOIN messages m ON u.id = m.sender_id
GROUP BY u.id
ORDER BY message_count DESC
LIMIT 10;
```

**Управление пользователями:**
```sql
-- Просмотр всех пользователей
SELECT id, username, is_online, status, is_admin, created_at 
FROM users 
ORDER BY created_at DESC;

-- Поиск пользователя
SELECT * FROM users WHERE username LIKE '%иван%';

-- Блокировка пользователя (удаление)
DELETE FROM users WHERE id = 5;

-- Назначение администратора
UPDATE users SET is_admin = TRUE WHERE id = 3;

-- Сброс пароля (требуется новый хеш)
UPDATE users SET password_hash = '$2b$12$...новый_хеш...' WHERE id = 2;
```

**Управление сообщениями:**
```sql
-- Просмотр всех сообщений (с именами пользователей)
SELECT 
    m.id,
    s.username as sender,
    r.username as receiver,
    m.content,
    m.message_type,
    m.timestamp,
    m.is_read
FROM messages m
JOIN users s ON m.sender_id = s.id
JOIN users r ON m.receiver_id = r.id
ORDER BY m.timestamp DESC
LIMIT 100;

-- Поиск сообщений по содержанию
SELECT * FROM messages WHERE content LIKE '%важное%';

-- Удаление старых сообщений (старше 90 дней)
DELETE FROM messages 
WHERE timestamp < datetime('now', '-90 days');

-- Очистка файловых данных (освобождение места)
UPDATE messages SET file_data = NULL 
WHERE message_type = 'image' 
AND timestamp < datetime('now', '-30 days');
```

### 3.4. Оптимизация базы данных

#### 3.4.1. Очистка и вакуумирование
```bash
# Резервное копирование перед оптимизацией
cp messenger.db messenger_backup_$(date +%Y%m%d).db

# Оптимизация базы данных
sqlite3 messenger.db "VACUUM;"

# Анализ производительности
sqlite3 messenger.db "ANALYZE;"

# Перестроение индексов
sqlite3 messenger.db "REINDEX;"
```

#### 3.4.2. Настройка параметров SQLite
```python
# В коде сервера при подключении к БД
import sqlite3

def get_db_connection():
    conn = sqlite3.connect('messenger.db')
    
    # Оптимизация производительности
    conn.execute("PRAGMA journal_mode = WAL;")  # Write-Ahead Logging
    conn.execute("PRAGMA synchronous = NORMAL;")  # Баланс скорости и надежности
    conn.execute("PRAGMA cache_size = -2000;")  # Кэш 2MB
    conn.execute("PRAGMA foreign_keys = ON;")  # Включение внешних ключей
    conn.execute("PRAGMA temp_store = MEMORY;")  # Временные таблицы в памяти
    
    conn.row_factory = sqlite3.Row
    return conn
```

#### 3.4.3. Мониторинг производительности
```sql
-- Текущие подключения к БД
PRAGMA database_list;

-- Статистика использования
PRAGMA stats;

-- Размер таблиц
SELECT 
    name as table_name,
    (SELECT COUNT(*) FROM sqlite_master WHERE type='index' AND tbl_name=name) as index_count,
    (pgsize/1024.0/1024.0) as size_mb
FROM dbstat
WHERE name NOT LIKE 'sqlite_%'
ORDER BY size_mb DESC;
```

### 3.5. Миграции базы данных

#### 3.5.1. Создание миграции
```python
# migrations/v2_add_user_settings.py
import sqlite3
import logging

logger = logging.getLogger(__name__)

def migrate_v2():
    """Добавление колонки settings к таблице users"""
    conn = sqlite3.connect('messenger.db')
    cursor = conn.cursor()
    
    try:
        # Проверяем, существует ли уже колонка
        cursor.execute("PRAGMA table_info(users)")
        columns = [col[1] for col in cursor.fetchall()]
        
        if 'settings' not in columns:
            cursor.execute("ALTER TABLE users ADD COLUMN settings TEXT DEFAULT '{}'")
            logger.info("Колонка 'settings' добавлена к таблице 'users'")
        else:
            logger.info("Колонка 'settings' уже существует")
            
        conn.commit()
        
    except Exception as e:
        logger.error(f"Ошибка при выполнении миграции: {e}")
        conn.rollback()
        
    finally:
        conn.close()
```

#### 3.5.2. Система управления миграциями
```bash
# migrate.sh
#!/bin/bash

DB_FILE="messenger.db"
MIGRATIONS_DIR="migrations"

echo "Запуск миграций базы данных..."

for migration in $(ls $MIGRATIONS_DIR/*.py | sort); do
    echo "Выполнение миграции: $(basename $migration)"
    python $migration
    
    if [ $? -eq 0 ]; then
        echo "Миграция успешно выполнена"
    else
        echo "Ошибка при выполнении миграции"
        exit 1
    fi
done

echo "Все миграции выполнены успешно"
```

---

## 4. Мониторинг и логирование

### 4.1. Настройка логирования

#### 4.1.1. Конфигурация логирования сервера
```python
# logging_config.py
import logging
import logging.handlers
from pathlib import Path

def setup_logging():
    # Создание директории для логов
    log_dir = Path("logs")
    log_dir.mkdir(exist_ok=True)
    
    # Настройка формата логов
    log_format = '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    date_format = '%Y-%m-%d %H:%M:%S'
    
    # Основной логгер
    logger = logging.getLogger()
    logger.setLevel(logging.INFO)
    
    # Файловый обработчик (ротация по размеру)
    file_handler = logging.handlers.RotatingFileHandler(
        filename=log_dir / 'server.log',
        maxBytes=10*1024*1024,  # 10 MB
        backupCount=5,
        encoding='utf-8'
    )
    file_handler.setFormatter(logging.Formatter(log_format, date_format))
    
    # Консольный обработчик
    console_handler = logging.StreamHandler()
    console_handler.setFormatter(logging.Formatter(log_format, date_format))
    
    # Добавление обработчиков
    logger.addHandler(file_handler)
    logger.addHandler(console_handler)
    
    # Логгер для WebSocket
    websocket_logger = logging.getLogger('websockets')
    websocket_logger.setLevel(logging.WARNING)
    
    return logger

# Использование
logger = setup_logging()
logger.info("Сервер запущен")
logger.error("Ошибка подключения к БД")
```

#### 4.1.2. Уровни логирования
| Уровень | Описание | Когда использовать |
|---------|----------|-------------------|
| DEBUG | Отладочная информация | Разработка, поиск проблем |
| INFO | Информационные сообщения | Нормальная работа системы |
| WARNING | Предупреждения | Потенциальные проблемы |
| ERROR | Ошибки | Сбои в работе, но система работает |
| CRITICAL | Критические ошибки | Система не работает |

### 4.2. Мониторинг системы

#### 4.2.1. Скрипт мониторинга
```python
# monitoring.py
import requests
import sqlite3
import psutil
import logging
from datetime import datetime

class SystemMonitor:
    def __init__(self, server_url):
        self.server_url = server_url
        self.logger = logging.getLogger(__name__)
    
    def check_server_health(self):
        """Проверка здоровья сервера"""
        checks = {}
        
        try:
            # Проверка доступности API
            response = requests.get(f"{self.server_url}/docs", timeout=5)
            checks['api_available'] = response.status_code == 200
        except:
            checks['api_available'] = False
        
        # Проверка базы данных
        try:
            conn = sqlite3.connect('messenger.db')
            cursor = conn.cursor()
            cursor.execute("SELECT 1")
            checks['database_available'] = True
            conn.close()
        except:
            checks['database_available'] = False
        
        # Проверка использования ресурсов
        checks['cpu_percent'] = psutil.cpu_percent(interval=1)
        checks['memory_percent'] = psutil.virtual_memory().percent
        checks['disk_usage'] = psutil.disk_usage('.').percent
        
        # Проверка количества подключений
        if checks['database_available']:
            conn = sqlite3.connect('messenger.db')
            cursor = conn.cursor()
            cursor.execute("SELECT COUNT(*) FROM users WHERE is_online = TRUE")
            checks['online_users'] = cursor.fetchone()[0]
            conn.close()
        
        return checks
    
    def generate_report(self):
        """Генерация отчета о состоянии системы"""
        checks = self.check_server_health()
        
        report = f"""
        Отчет о состоянии системы - {datetime.now()}
        {'='*50}
        
        Доступность сервисов:
        • API сервер: {'✅ Доступен' if checks.get('api_available') else '❌ Недоступен'}
        • База данных: {'✅ Доступна' if checks.get('database_available') else '❌ Недоступна'}
        
        Использование ресурсов:
        • Загрузка CPU: {checks.get('cpu_percent', 'N/A')}%
        • Использование RAM: {checks.get('memory_percent', 'N/A')}%
        • Использование диска: {checks.get('disk_usage', 'N/A')}%
        
        Статистика пользователей:
        • Онлайн пользователей: {checks.get('online_users', 'N/A')}
        
        Рекомендации:
        """
        
        # Добавление рекомендаций
        if checks.get('cpu_percent', 0) > 80:
            report += "• ⚠️ Высокая загрузка CPU\n"
        if checks.get('memory_percent', 0) > 85:
            report += "• ⚠️ Высокое использование памяти\n"
        if checks.get('disk_usage', 0) > 90:
            report += "• ⚠️ Мало свободного места на диске\n"
        
        return report
    
    def log_health_check(self):
        """Логирование проверки здоровья"""
        checks = self.check_server_health()
        
        if not checks.get('api_available'):
            self.logger.error("API сервер недоступен")
        if not checks.get('database_available'):
            self.logger.error("База данных недоступен")
        
        self.logger.info(f"Загрузка CPU: {checks.get('cpu_percent')}%")
        self.logger.info(f"Использование RAM: {checks.get('memory_percent')}%")

# Использование
monitor = SystemMonitor("http://localhost:8000")
report = monitor.generate_report()
print(report)
```

#### 4.2.2. Автоматический мониторинг
```bash
#!/bin/bash
# auto_monitor.sh

SERVER_URL="http://localhost:8000"
LOG_FILE="/opt/lmessenger/logs/monitoring.log"
ALERT_EMAIL="admin@school.edu"

# Проверка доступности сервера
if ! curl -s --head $SERVER_URL/docs > /dev/null; then
    echo "$(date) - Сервер недоступен" >> $LOG_FILE
    # Отправка уведомления
    echo "Сервер LMessenger недоступен" | mail -s "ALERT: Сервер недоступен" $ALERT_EMAIL
    # Попытка перезапуска
    systemctl restart lmessenger
fi

# Проверка дискового пространства
DISK_USAGE=$(df / | awk 'NR==2 {print $5}' | sed 's/%//')
if [ $DISK_USAGE -gt 90 ]; then
    echo "$(date) - Мало свободного места: $DISK_USAGE%" >> $LOG_FILE
fi

# Проверка использования памяти
MEM_USAGE=$(free | awk '/Mem/ {printf("%.0f"), $3/$2*100}')
if [ $MEM_USAGE -gt 85 ]; then
    echo "$(date) - Высокое использование памяти: $MEM_USAGE%" >> $LOG_FILE
fi
```

### 4.3. Анализ логов

#### 4.3.1. Полезные команды для анализа логов
```bash
# Просмотр последних записей
tail -f /opt/lmessenger/logs/server.log

# Поиск ошибок
grep -i "error" /opt/lmessenger/logs/server.log

# Поиск по времени
awk '/2024-01-15 10:/' /opt/lmessenger/logs/server.log

# Подсчет ошибок за день
grep -c "ERROR" /opt/lmessenger/logs/server.log

# Топ IP адресов с ошибками
grep "ERROR" /opt/lmessenger/logs/server.log | awk '{print $NF}' | sort | uniq -c | sort -rn

# Генерация отчета
cat /opt/lmessenger/logs/server.log | \
  awk '{print $1, $2}' | \
  cut -d: -f1,2 | \
  uniq -c | \
  sort -rn > daily_report.txt
```

#### 4.3.2. Скрипт анализа логов
```python
# log_analyzer.py
import re
from collections import Counter
from datetime import datetime, timedelta

def analyze_logs(log_file):
    """Анализ логов сервера"""
    
    with open(log_file, 'r', encoding='utf-8') as f:
        logs = f.readlines()
    
    analysis = {
        'total_lines': len(logs),
        'errors': [],
        'warnings': [],
        'ip_addresses': Counter(),
        'endpoints': Counter(),
        'hourly_activity': Counter()
    }
    
    # Паттерны для анализа
    error_pattern = re.compile(r'ERROR - (.*)')
    warning_pattern = re.compile(r'WARNING - (.*)')
    ip_pattern = re.compile(r'\d+\.\d+\.\d+\.\d+')
    endpoint_pattern = re.compile(r'/(?:auth|messages|users|admin)/[^\s]*')
    time_pattern = re.compile(r'\d{4}-\d{2}-\d{2} (\d{2}):')
    
    for line in logs:
        # Поиск ошибок
        error_match = error_pattern.search(line)
        if error_match:
            analysis['errors'].append(error_match.group(1))
        
        # Поиск предупреждений
        warning_match = warning_pattern.search(line)
        if warning_match:
            analysis['warnings'].append(warning_match.group(1))
        
        # Подсчет IP адресов
        ip_match = ip_pattern.search(line)
        if ip_match:
            analysis['ip_addresses'][ip_match.group()] += 1
        
        # Подсчет endpoints
        endpoint_match = endpoint_pattern.search(line)
        if endpoint_match:
            analysis['endpoints'][endpoint_match.group()] += 1
        
        # Анализ по часам
        time_match = time_pattern.search(line)
        if time_match:
            hour = time_match.group(1)
            analysis['hourly_activity'][hour] += 1
    
    return analysis

def generate_log_report(analysis):
    """Генерация отчета по логам"""
    
    report = f"""
    Анализ логов сервера LMessenger
    Отчет сгенерирован: {datetime.now()}
    {'='*60}
    
    Общая статистика:
    • Всего записей в логе: {analysis['total_lines']}
    • Количество ошибок: {len(analysis['errors'])}
    • Количество предупреждений: {len(analysis['warnings'])}
    
    Топ 5 самых частых ошибок:
    """
    
    error_counter = Counter(analysis['errors'])
    for error, count in error_counter.most_common(5):
        report += f"    • {error}: {count} раз\n"
    
    report += "\nТоп 5 IP адресов по активности:\n"
    for ip, count in analysis['ip_addresses'].most_common(5):
        report += f"    • {ip}: {count} запросов\n"
    
    report += "\nТоп 5 endpoints по популярности:\n"
    for endpoint, count in analysis['endpoints'].most_common(5):
        report += f"    • {endpoint}: {count} запросов\n"
    
    report += "\nАктивность по часам:\n"
    for hour in sorted(analysis['hourly_activity'].keys()):
        count = analysis['hourly_activity'][hour]
        report += f"    • {hour}:00 - {count} событий\n"
    
    # Рекомендации
    report += "\nРекомендации:\n"
    if len(analysis['errors']) > 100:
        report += "• ⚠️ Высокое количество ошибок. Проверьте стабильность системы.\n"
    if len(analysis['warnings']) > 500:
        report += "• ⚠️ Много предупреждений. Возможны проблемы с конфигурацией.\n"
    
    return report

# Использование
analysis = analyze_logs('/opt/lmessenger/logs/server.log')
report = generate_log_report(analysis)
print(report)

# Сохранение отчета в файл
with open('/opt/lmessenger/logs/log_report.txt', 'w') as f:
    f.write(report)
```

### 4.4. Уведомления администратора

#### 4.4.1. Настройка email уведомлений
```python
# notifications.py
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
import logging

class AdminNotifier:
    def __init__(self, smtp_server, smtp_port, username, password, admin_email):
        self.smtp_server = smtp_server
        self.smtp_port = smtp_port
        self.username = username
        self.password = password
        self.admin_email = admin_email
        self.logger = logging.getLogger(__name__)
    
    def send_alert(self, subject, message):
        """Отправка уведомления администратору"""
        
        msg = MIMEMultipart()
        msg['From'] = self.username
        msg['To'] = self.admin_email
        msg['Subject'] = f"[LMessenger Alert] {subject}"
        
        msg.attach(MIMEText(message, 'plain'))
        
        try:
            with smtplib.SMTP(self.smtp_server, self.smtp_port) as server:
                server.starttls()
                server.login(self.username, self.password)
                server.send_message(msg)
            
            self.logger.info(f"Уведомление отправлено: {subject}")
            
        except Exception as e:
            self.logger.error(f"Ошибка отправки уведомления: {e}")
    
    def send_daily_report(self, report_content):
        """Отправка ежедневного отчета"""
        subject = "Ежедневный отчет LMessenger"
        self.send_alert(subject, report_content)
    
    def send_error_alert(self, error_message):
        """Отправка уведомления об ошибке"""
        subject = "Критическая ошибка сервера"
        message = f"Произошла критическая ошибка:\n\n{error_message}"
        self.send_alert(subject, message)

# Настройка в конфигурации
EMAIL_CONFIG = {
    "smtp_server": "smtp.gmail.com",
    "smtp_port": 587,
    "username": "lmessenger@school.edu",
    "password": "your_password",
    "admin_email": "admin@school.edu"
}
```

---

## 5. Резервное копирование

### 5.1. Стратегия резервного копирования

#### 5.1.1. Рекомендуемая стратегия
```
Резервное копирование LMessenger:
├── Ежедневные инкрементальные бэкапы (хранятся 7 дней)
├── Еженедельные полные бэкапы (хранятся 4 недели)
├── Ежемесячные архивы (хранятся 12 месяцев)
└── Годовые архивы (хранятся бессрочно)
```

#### 5.1.2. Что подлежит резервному копированию
1. **База данных** (`messenger.db`) - самый важный компонент
2. **Файлы конфигурации** (`config.py`, `.env`)
3. **Логи сервера** (`logs/` директория)
4. **Файлы сообщений** (опционально, если хранятся отдельно)

### 5.2. Автоматическое резервное копирование

#### 5.2.1. Скрипт резервного копирования
```bash
#!/bin/bash
# backup_server.sh

# Конфигурация
BACKUP_DIR="/var/backups/lmessenger"
DB_FILE="/opt/lmessenger/messenger.db"
CONFIG_DIR="/opt/lmessenger"
LOG_DIR="/opt/lmessenger/logs"
RETENTION_DAILY=7
RETENTION_WEEKLY=4
RETENTION_MONTHLY=12

# Создание директорий
mkdir -p $BACKUP_DIR/{daily,weekly,monthly}

# Генерация имен файлов
TIMESTAMP=$(date +%Y%m%d_%H%M%S)
DAILY_BACKUP="$BACKUP_DIR/daily/backup_$TIMESTAMP.tar.gz"
WEEKLY_BACKUP="$BACKUP_DIR/weekly/backup_$(date +%Y%m%d).tar.gz"
MONTHLY_BACKUP="$BACKUP_DIR/monthly/backup_$(date +%Y%m).tar.gz"

# Создание резервной копии
echo "Создание резервной копии..."
tar -czf $DAILY_BACKUP \
    $DB_FILE \
    $CONFIG_DIR/*.py \
    $LOG_DIR/*.log 2>/dev/null

# Проверка успешности создания
if [ $? -eq 0 ]; then
    echo "Резервная копия создана: $DAILY_BACKUP"
    
    # Еженедельный бэкап (по воскресеньям)
    if [ $(date +%u) -eq 7 ]; then
        cp $DAILY_BACKUP $WEEKLY_BACKUP
        echo "Создана еженедельная копия: $WEEKLY_BACKUP"
    fi
    
    # Ежемесячный бэкап (в первый день месяца)
    if [ $(date +%d) -eq 01 ]; then
        cp $DAILY_BACKUP $MONTHLY_BACKUP
        echo "Создана ежемесячная копия: $MONTHLY_BACKUP"
    fi
    
else
    echo "Ошибка при создании резервной копии!"
    exit 1
fi

# Очистка старых бэкапов
echo "Очистка старых резервных копий..."

# Ежедневные (старше 7 дней)
find $BACKUP_DIR/daily -name "*.tar.gz" -mtime +$RETENTION_DAILY -delete

# Еженедельные (старше 4 недель)
find $BACKUP_DIR/weekly -name "*.tar.gz" -mtime +$(($RETENTION_WEEKLY * 7)) -delete

# Ежемесячные (старше 12 месяцев)
find $BACKUP_DIR/monthly -name "*.tar.gz" -mtime +$(($RETENTION_MONTHLY * 30)) -delete

echo "Резервное копирование завершено успешно."
```

#### 5.2.2. Резервное копирование базы данных
```python
# backup_database.py
import sqlite3
import gzip
import shutil
from datetime import datetime
from pathlib import Path
import logging

logger = logging.getLogger(__name__)

class DatabaseBackup:
    def __init__(self, db_path, backup_dir):
        self.db_path = Path(db_path)
        self.backup_dir = Path(backup_dir)
        self.backup_dir.mkdir(exist_ok=True)
    
    def create_backup(self):
        """Создание резервной копии базы данных"""
        
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        backup_file = self.backup_dir / f"messenger_{timestamp}.db.gz"
        
        try:
            # Создание временной копии базы данных
            temp_backup = self.backup_dir / "temp_backup.db"
            
            # Копирование с использованием SQLite backup API
            source_conn = sqlite3.connect(self.db_path)
            backup_conn = sqlite3.connect(temp_backup)
            
            with backup_conn:
                source_conn.backup(backup_conn)
            
            source_conn.close()
            backup_conn.close()
            
            # Сжатие бэкапа
            with open(temp_backup, 'rb') as f_in:
                with gzip.open(backup_file, 'wb') as f_out:
                    shutil.copyfileobj(f_in, f_out)
            
            # Удаление временного файла
            temp_backup.unlink()
            
            logger.info(f"Резервная копия создана: {backup_file}")
            
            # Проверка целостности бэкапа
            if self.verify_backup(backup_file):
                logger.info("Целостность бэкапа проверена")
                return True
            else:
                logger.error("Ошибка проверки целостности бэкапа")
                return False
                
        except Exception as e:
            logger.error(f"Ошибка создания бэкапа: {e}")
            return False
    
    def verify_backup(self, backup_file):
        """Проверка целостности резервной копии"""
        try:
            # Распаковка и проверка
            with gzip.open(backup_file, 'rb') as f_in:
                with open(self.backup_dir / "verify_temp.db", 'wb') as f_out:
                    shutil.copyfileobj(f_in, f_out)
            
            # Проверка базы данных
            conn = sqlite3.connect(self.backup_dir / "verify_temp.db")
            cursor = conn.cursor()
            
            # Проверка основных таблиц
            cursor.execute("SELECT COUNT(*) FROM users")
            cursor.execute("SELECT COUNT(*) FROM messages")
            
            conn.close()
            
            # Удаление временного файла
            (self.backup_dir / "verify_temp.db").unlink()
            
            return True
            
        except:
            return False
    
    def cleanup_old_backups(self, days_to_keep=30):
        """Удаление старых резервных копий"""
        
        cutoff_date = datetime.now().timestamp() - (days_to_keep * 24 * 3600)
        
        for backup_file in self.backup_dir.glob("*.db.gz"):
            if backup_file.stat().st_mtime < cutoff_date:
                backup_file.unlink()
                logger.info(f"Удален старый бэкап: {backup_file}")

# Использование
backup_manager = DatabaseBackup(
    db_path="/opt/lmessenger/messenger.db",
    backup_dir="/var/backups/lmessenger/db"
)

# Создание бэкапа
backup_manager.create_backup()

# Очистка старых бэкапов
backup_manager.cleanup_old_backups(days_to_keep=30)
```

### 5.3. Восстановление из резервной копии

#### 5.3.1. Скрипт восстановления
```bash
#!/bin/bash
# restore_backup.sh

# Конфигурация
BACKUP_DIR="/var/backups/lmessenger"
DB_FILE="/opt/lmessenger/messenger.db"
SERVICE_NAME="lmessenger"

echo "Восстановление LMessenger из резервной копии"
echo "============================================"

# Список доступных бэкапов
echo "Доступные резервные копии:"
BACKUPS=($(ls -t $BACKUP_DIR/daily/*.tar.gz 2>/dev/null))
for i in "${!BACKUPS[@]}"; do
    echo "  $((i+1))) $(basename ${BACKUPS[$i]})"
done

if [ ${#BACKUPS[@]} -eq 0 ]; then
    echo "Резервные копии не найдены!"
    exit 1
fi

# Выбор бэкапа
read -p "Выберите номер резервной копии для восстановления: " choice
if [[ ! $choice =~ ^[0-9]+$ ]] || [ $choice -lt 1 ] || [ $choice -gt ${#BACKUPS[@]} ]; then
    echo "Неверный выбор!"
    exit 1
fi

SELECTED_BACKUP=${BACKUPS[$((choice-1))]}

# Подтверждение
echo "Вы выбрали: $(basename $SELECTED_BACKUP)"
read -p "Вы уверены? Это перезапишет текущие данные! (y/N): " confirm

if [[ ! $confirm =~ ^[Yy]$ ]]; then
    echo "Восстановление отменено."
    exit 0
fi

# Остановка сервера
echo "Остановка сервера..."
systemctl stop $SERVICE_NAME

# Восстановление из бэкапа
echo "Восстановление данных..."
tar -xzf $SELECTED_BACKUP -C /tmp/lmessenger_restore

# Проверка файлов
if [ -f "/tmp/lmessenger_restore/messenger.db" ]; then
    # Создание резервной копии текущей БД
    cp $DB_FILE "$DB_FILE.bak_$(date +%Y%m%d_%H%M%S)"
    
    # Восстановление БД
    cp "/tmp/lmessenger_restore/messenger.db" $DB_FILE
    echo "База данных восстановлена."
fi

# Восстановление конфигурации (если есть)
if [ -f "/tmp/lmessenger_restore/config.py" ]; then
    cp "/tmp/lmessenger_restore/config.py" "$CONFIG_DIR/config.py.restored"
    echo "Конфигурация восстановлена (сохранена как .restored)."
fi

# Очистка временных файлов
rm -rf /tmp/lmessenger_restore

# Запуск сервера
echo "Запуск сервера..."
systemctl start $SERVICE_NAME

echo "Восстановление завершено успешно!"
echo "Текущая БД сохранена как: $DB_FILE.bak_$(date +%Y%m%d_%H%M%S)"
```

#### 5.3.2. Восстановление отдельных таблиц
```python
# restore_tables.py
import sqlite3
import gzip
import tempfile
from pathlib import Path

def restore_single_table(backup_file, table_name):
    """Восстановление отдельной таблицы из бэкапа"""
    
    # Распаковка бэкапа
    with gzip.open(backup_file, 'rb') as f_in:
        with tempfile.NamedTemporaryFile(suffix='.db', delete=False) as f_out:
            f_out.write(f_in.read())
            temp_db = f_out.name
    
    try:
        # Подключение к основной и резервной БД
        main_conn = sqlite3.connect('messenger.db')
        backup_conn = sqlite3.connect(temp_db)
        
        # Проверка существования таблицы в бэкапе
        backup_cursor = backup_conn.cursor()
        backup_cursor.execute(f"SELECT name FROM sqlite_master WHERE type='table' AND name='{table_name}'")
        
        if not backup_cursor.fetchone():
            print(f"Таблица '{table_name}' не найдена в бэкапе")
            return False
        
        # Резервное копирование текущей таблицы
        main_cursor = main_conn.cursor()
        main_cursor.execute(f"CREATE TABLE IF NOT EXISTS {table_name}_backup AS SELECT * FROM {table_name}")
        main_cursor.execute(f"DELETE FROM {table_name}")
        
        # Копирование данных из бэкапа
        backup_cursor.execute(f"SELECT * FROM {table_name}")
        rows = backup_cursor.fetchall()
        
        if rows:
            # Получение названий колонок
            backup_cursor.execute(f"PRAGMA table_info({table_name})")
            columns = [col[1] for col in backup_cursor.fetchall()]
            placeholders = ','.join(['?' for _ in columns])
            
            # Вставка данных
            main_cursor.executemany(
                f"INSERT INTO {table_name} VALUES ({placeholders})",
                rows
            )
        
        main_conn.commit()
        
        print(f"Таблица '{table_name}' восстановлена. {len(rows)} записей.")
        
        return True
        
    except Exception as e:
        print(f"Ошибка восстановления: {e}")
        return False
        
    finally:
        # Закрытие соединений
        if 'main_conn' in locals():
            main_conn.close()
        if 'backup_conn' in locals():
            backup_conn.close()
        
        # Удаление временного файла
        Path(temp_db).unlink()

# Пример использования
restore_single_table(
    backup_file="/var/backups/lmessenger/db/messenger_20240115.db.gz",
    table_name="users"
)
```

### 5.4. Планирование автоматического резервного копирования

#### 5.4.1. Настройка cron заданий
```bash
# /etc/cron.d/lmessenger-backup

# Ежедневное резервное копирование в 2:00 ночи
0 2 * * * root /opt/lmessenger/scripts/backup_server.sh >> /var/log/lmessenger_backup.log 2>&1

# Еженедельная проверка целостности в воскресенье в 3:00
0 3 * * 0 root /opt/lmessenger/scripts/verify_backups.sh >> /var/log/lmessenger_verify.log 2>&1

# Ежемесячная очистка логов в первый день месяца в 4:00
0 4 1 * * root /opt/lmessenger/scripts/cleanup_logs.sh >> /var/log/lmessenger_cleanup.log 2>&1
```

#### 5.4.2. Проверка целостности бэкапов
```bash
#!/bin/bash
# verify_backups.sh

BACKUP_DIR="/var/backups/lmessenger"
LOG_FILE="/var/log/lmessenger_backup_verify.log"

echo "$(date) - Начало проверки резервных копий" >> $LOG_FILE

# Проверка последнего ежедневного бэкапа
LATEST_BACKUP=$(ls -t $BACKUP_DIR/daily/*.tar.gz 2>/dev/null | head -1)

if [ -z "$LATEST_BACKUP" ]; then
    echo "$(date) - ERROR: Резервные копии не найдены" >> $LOG_FILE
    exit 1
fi

# Проверка целостности архива
if tar -tzf "$LATEST_BACKUP" > /dev/null 2>&1; then
    echo "$(date) - OK: Бэкап $LATEST_BACKUP прошел проверку" >> $LOG_FILE
else
    echo "$(date) - ERROR: Бэкап $LATEST_BACKUP поврежден" >> $LOG_FILE
    
    # Отправка уведомления
    echo "Резервная копия LMessenger повреждена: $(basename $LATEST_BACKUP)" | \
        mail -s "ALERT: Поврежден бэкап LMessenger" admin@school.edu
fi

# Проверка размера бэкапа
SIZE=$(stat -c%s "$LATEST_BACKUP")
if [ $SIZE -lt 10240 ]; then  # Меньше 10KB
    echo "$(date) - WARNING: Бэкап слишком мал: $SIZE байт" >> $LOG_FILE
fi

echo "$(date) - Проверка завершена" >> $LOG_FILE
```

### 5.5. Резервное копирование в облако (опционально)

#### 5.5.1. Интеграция с Google Drive
```python
# cloud_backup.py
from pydrive2.auth import GoogleAuth
from pydrive2.drive import GoogleDrive
from pathlib import Path
import logging

logger = logging.getLogger(__name__)

class GoogleDriveBackup:
    def __init__(self, credentials_file):
        self.credentials_file = credentials_file
        self.drive = self.authenticate()
        self.backup_folder_id = self.get_or_create_folder('LMessenger_Backups')
    
    def authenticate(self):
        """Аутентификация в Google Drive"""
        gauth = GoogleAuth()
        
        # Попытка загрузить сохраненные учетные данные
        gauth.LoadCredentialsFile(self.credentials_file)
        
        if gauth.credentials is None:
            # Аутентификация через браузер
            gauth.LocalWebserverAuth()
        elif gauth.access_token_expired:
            # Обновление токена
            gauth.Refresh()
        else:
            # Авторизация
            gauth.Authorize()
        
        # Сохранение учетных данных
        gauth.SaveCredentialsFile(self.credentials_file)
        
        return GoogleDrive(gauth)
    
    def get_or_create_folder(self, folder_name):
        """Поиск или создание папки для бэкапов"""
        
        # Поиск существующей папки
        query = f"title='{folder_name}' and mimeType='application/vnd.google-apps.folder' and trashed=false"
        folder_list = self.drive.ListFile({'q': query}).GetList()
        
        if folder_list:
            return folder_list[0]['id']
        
        # Создание новой папки
        folder_metadata = {
            'title': folder_name,
            'mimeType': 'application/vnd.google-apps.folder'
        }
        
        folder = self.drive.CreateFile(folder_metadata)
        folder.Upload()
        
        return folder['id']
    
    def upload_backup(self, backup_file):
        """Загрузка бэкапа в Google Drive"""
        
        file_name = Path(backup_file).name
        
        # Создание метаданных файла
        file_metadata = {
            'title': file_name,
            'parents': [{'id': self.backup_folder_id}]
        }
        
        # Загрузка файла
        file = self.drive.CreateFile(file_metadata)
        file.SetContentFile(backup_file)
        file.Upload()
        
        logger.info(f"Бэкап загружен в Google Drive: {file_name}")
        
        # Получение ссылки на файл
        file.InsertPermission({
            'type': 'anyone',
            'value': 'anyone',
            'role': 'reader'
        })
        
        return file['alternateLink']
    
    def list_backups(self):
        """Список бэкапов в облаке"""
        
        query = f"'{self.backup_folder_id}' in parents and trashed=false"
        file_list = self.drive.ListFile({'q': query}).GetList()
        
        backups = []
        for file in file_list:
            backups.append({
                'name': file['title'],
                'id': file['id'],
                'created': file['createdDate'],
                'size': int(file['fileSize'])
            })
        
        return backups

# Использование
backup_to_cloud = GoogleDriveBackup('credentials.json')
backup_to_cloud.upload_backup('/var/backups/lmessenger/daily/backup_20240115.tar.gz')
```

---

## 6. Устранение неполадок

### 6.1. Распространенные проблемы и решения

| Проблема | Возможные причины | Решения |
|----------|-------------------|---------|
| **Сервер не запускается** | 1. Занят порт 8000<br>2. Отсутствуют зависимости<br>3. Ошибка в конфигурации | 1. `netstat -tulpn | grep 8000`<br>2. `pip install -r requirements.txt`<br>3. Проверить `config.py` |
| **Клиенты не могут подключиться** | 1. Брандмауэр блокирует порт<br>2. Неверный IP сервера<br>3. Сервер не запущен | 1. Проверить правила брандмауэра<br>2. Проверить настройки клиента<br>3. Проверить статус сервера |
| **Ошибки базы данных** | 1. Повреждена БД<br>2. Нет прав на запись<br>3. Не хватает места | 1. Восстановить из бэкапа<br>2. `chmod 666 messenger.db`<br>3. Очистить место на диске |
| **Медленная работа** | 1. Высокая нагрузка<br>2. Фрагментация БД<br>3. Недостаточно RAM | 1. Добавить индексы<br>2. Выполнить `VACUUM`<br>3. Увеличить кэш SQLite |
| **Ошибки WebSocket** | 1. Проблемы с сетью<br>2. Таймаут соединения<br>3. Ошибки в коде | 1. Проверить сетевое соединение<br>2. Увеличить таймауты<br>3. Проверить логи сервера |

### 6.2. Диагностические команды

```bash
# Проверка состояния сервера
systemctl status lmessenger

# Просмотр логов в реальном времени
journalctl -u lmessenger -f

# Проверка сетевых подключений
ss -tulpn | grep 8000

# Проверка использования ресурсов
top -p $(pgrep -f "python main.py")

# Проверка целостности базы данных
sqlite3 messenger.db "PRAGMA integrity_check;"

# Проверка свободного места
df -h /opt/lmessenger
```

### 6.3. Контакты для технической поддержки

- **Разработчик:** Малиневский Егор Сергеевич
- **Группа:** 21ИС-24
- **Email:** [ваш-email@edu.ru] - на данный момент не создана

---

## 7. Заключение

### 7.1. Рекомендации по обслуживанию

1. **Ежедневно:** Проверка логов и состояния сервера
2. **Еженедельно:** Очистка старых логов, проверка бэкапов
3. **Ежемесячно:** Обновление зависимостей, оптимизация БД
4. **Ежеквартально:** Полный аудит безопасности системы

### 7.2. Контрольный список администратора

- [ ] Сервер установлен и настроен
- [ ] База данных инициализирована
- [ ] Созданы учетные записи администраторов
- [ ] Настроено автоматическое резервное копирование
- [ ] Настроен мониторинг и логирование
- [ ] Протестировано восстановление из бэкапа
- [ ] Клиенты настроены и могут подключаться
- [ ] Документация сохранена в доступном месте

### 7.3. Дополнительные ресурсы

1. **Документация FastAPI:** https://fastapi.tiangolo.com
2. **Документация SQLite:** https://sqlite.org/docs.html
3. **Документация PyQt5:** https://www.riverbankcomputing.com/static/Docs/PyQt5
4. **Руководство по Linux администрации:** https://linux.die.net/man/

---

**Версия руководства:** 1.2  
**Дата последнего обновления:** 2026  
**Автор:** Малиневский Егор Сергеевич, группа 21ИС-24

*Данное руководство является собственностью разработчика и предназначено исключительно для администраторов системы "Локальный мессенджер".*