# Архитектурная документация
## Локальный мессенджер для образовательных учреждений

**Разработчик:** Малиневский Егор Сергеевич/21ИС-24  
**Версия документа:** 1.0  
**Дата создания:** 2026
**Статус:** Актуальный

---

## 1. Диаграмма компонентов системы

### 1.1. Общая диаграмма компонентов

```mermaid
graph TB
    subgraph "Клиентское приложение (PyQt5)"
        UI[UI Layer<br/>PyQt5 Widgets]
        BL[Business Logic<br/>Models & Controllers]
        NET[Network Layer<br/>HTTP/WebSocket]
    end
    
    subgraph "Серверное приложение (FastAPI)"
        API[API Layer<br/>FastAPI Endpoints]
        BLL[Business Logic Layer<br/>Services & Models]
        DAL[Data Access Layer<br/>SQLite Repository]
    end
    
    subgraph "Инфраструктура"
        DB[(SQLite Database)]
        WS[WebSocket Manager]
        AUTH[JWT Authentication]
    end
    
    UI --> BL
    BL --> NET
    NET --> API
    API --> BLL
    BLL --> DAL
    DAL --> DB
    API --> WS
    API --> AUTH
    WS --> NET
    AUTH --> BL
```

### 1.2. Детализация клиентских компонентов

#### 1.2.1. UI Layer Components
```
┌─────────────────────────────────────────┐
│             UI Layer (PyQt5)            │
├─────────────────────────────────────────┤
│                                         │
│  ┌──────────────────────────────────┐  │
│  │        MainWindow (QMainWindow)  │  │
│  │  • Центральный виджет            │  │
│  │  • Меню-бар и статус-бар         │  │
│  │  • Управление вкладками чатов    │  │
│  └──────────────────────────────────┘  │
│                   │                     │
│  ┌──────────────────────────────────┐  │
│  │     ChatWidget (QWidget)         │  │
│  │  • Отображение сообщений         │  │
│  │  • Ввод и отправка сообщений     │  │
│  │  • Работа с файлами              │  │
│  │  • Контекстное меню              │  │
│  └──────────────────────────────────┘  │
│                   │                     │
│  ┌──────────────────────────────────┐  │
│  │    LoginDialog (QDialog)         │  │
│  │  • Форма входа                   │  │
│  │  • Форма регистрации             │  │
│  │  • Валидация данных              │  │
│  └──────────────────────────────────┘  │
└─────────────────────────────────────────┘
```

#### 1.2.2. Business Logic Layer Components
```python
# Модели данных
Message:
  - id: int
  - sender_id: int
  - receiver_id: int
  - content: str
  - timestamp: datetime
  - is_read: bool
  - message_type: str
  - file_data: Optional[str]
  - Методы: is_outgoing(), get_formatted_time()

User:
  - id: int
  - username: str
  - is_online: bool
  - last_seen: datetime
  - status: str
  - is_admin: bool

# Контроллеры
ChatController:
  - Управление логикой чата
  - Обработка ввода сообщений
  - Управление файлами

AuthController:
  - Управление аутентификацией
  - Работа с токенами
  - Валидация пользователей
```

#### 1.2.3. Network Layer Components
```
┌─────────────────────────────────────────┐
│           Network Layer                 │
├─────────────────────────────────────────┤
│                                         │
│  ┌──────────────────────────────────┐  │
│  │      HTTP Client (requests)      │  │
│  │  • Отправка REST запросов        │  │
│  │  • Обработка ответов             │  │
│  │  • Управление заголовками        │  │
│  │  • Обработка ошибок              │  │
│  └──────────────────────────────────┘  │
│                   │                     │
│  ┌──────────────────────────────────┐  │
│  │   WebSocket Client (websockets)  │  │
│  │  • Установка соединения          │  │
│  │  • Отправка/получение сообщений  │  │
│  │  • Keep-alive механизм           │  │
│  │  • Переподключение при обрыве    │  │
│  └──────────────────────────────────┘  │
│                   │                     │
│  ┌──────────────────────────────────┐  │
│  │          Timer (QTimer)          │  │
│  │  • Периодическое обновление      │  │
│  │  • Проверка новых сообщений      │  │
│  │  • Обновление статусов           │  │
│  └──────────────────────────────────┘  │
└─────────────────────────────────────────┘
```

### 1.3. Детализация серверных компонентов

#### 1.3.1. API Layer Components
```python
# FastAPI Application Structure
app = FastAPI()

# Роутеры
auth_router:    # /auth/*
  - POST /register
  - POST /login
  - POST /logout

messages_router: # /messages/*
  - GET / (список сообщений)
  - POST / (отправка сообщения)
  - DELETE /{id} (удаление сообщения)
  - PUT /{id}/read (отметка как прочитано)

users_router:    # /users/*
  - GET / (список пользователей)
  - GET /me (текущий пользователь)
  - GET /{id} (конкретный пользователь)

admin_router:    # /admin/*
  - GET /all-messages
  - GET /all-users

# WebSocket endpoint
@app.websocket("/ws/{user_id}")
async def websocket_endpoint(...)
```

#### 1.3.2. Business Logic Layer Components
```python
# Сервисы
AuthService:
  - create_access_token()
  - verify_password()
  - get_password_hash()

MessageService:
  - send_message()
  - get_conversation()
  - delete_message()
  - mark_as_read()

UserService:
  - create_user()
  - get_user_by_id()
  - update_user_status()
  - get_all_users()

# Модели предметной области
UserModel:
  - Бизнес-логика пользователей
  - Валидация данных
  - Преобразование объектов

MessageModel:
  - Бизнес-логика сообщений
  - Валидация типов сообщений
  - Обработка файлов
```

#### 1.3.3. Data Access Layer Components
```python
# Репозитории
UserRepository:
  - create()
  - find_by_id()
  - find_by_username()
  - update()
  - delete()
  - find_all()

MessageRepository:
  - create()
  - find_by_id()
  - find_conversation()
  - find_unread()
  - update()
  - delete()

# Unit of Work
class UnitOfWork:
  - __enter__()
  - __exit__()
  - commit()
  - rollback()
```

### 1.4. Взаимодействие компонентов

#### 1.4.1. Последовательность отправки сообщения
```mermaid
sequenceDiagram
    participant U as Пользователь
    participant CW as ChatWidget
    participant HC as HTTP Client
    participant API as API Server
    participant MM as MessageModel
    participant DB as Database
    participant WS as WebSocket Manager
    participant RC as Recipient Client

    U->>CW: Вводит сообщение
    CW->>HC: send_message()
    HC->>API: POST /messages
    API->>MM: create_message()
    MM->>DB: INSERT message
    DB-->>MM: message_id
    MM-->>API: Message object
    API-->>HC: 200 OK + message
    HC-->>CW: Успех отправки
    CW->>CW: add_message_to_display()
    
    API->>WS: send_personal_message()
    WS->>RC: WebSocket notification
    RC->>RC: handle_websocket_message()
```

#### 1.4.2. Последовательность удаления сообщения
```mermaid
sequenceDiagram
    participant U as Пользователь
    participant CW as ChatWidget
    participant HC as HTTP Client
    participant API as API Server
    participant MM as MessageModel
    participant DB as Database
    participant WS as WebSocket Manager
    participant OC as Other Clients

    U->>CW: ПКМ → "Удалить"
    CW->>HC: delete_message(id)
    HC->>API: DELETE /messages/{id}
    API->>MM: check_permissions()
    API->>DB: DELETE FROM messages
    DB-->>API: Success
    API-->>HC: 200 OK
    HC-->>CW: Успех удаления
    CW->>CW: _remove_message()
    
    API->>WS: broadcast_to_users()
    WS->>OC: message_deleted
    OC->>OC: _remove_message()
```

---

## 2. Диаграмма развертывания

### 2.1. Физическая архитектура развертывания

```mermaid
graph TB
    subgraph "Компьютерный класс"
        direction LR
        S[Сервер<br/>Windows/Linux<br/>FastAPI + SQLite]
        
        subgraph "Рабочие станции"
            C1[Клиент 1<br/>Windows 10<br/>PyQt5]
            C2[Клиент 2<br/>Windows 11<br/>PyQt5]
            C3[Клиент 3<br/>Ubuntu 22.04<br/>PyQt5]
            C4[Клиент N<br/>...]
        end
    end
    
    S -->|HTTP/WS:8000| C1
    S -->|HTTP/WS:8000| C2
    S -->|HTTP/WS:8000| C3
    S -->|HTTP/WS:8000| C4
    
    C1 -->|Switch/Router| S
    C2 -->|Switch/Router| S
    C3 -->|Switch/Router| S
    C4 -->|Switch/Router| S
```

### 2.2. Логическая схема сети

```
192.168.0.0/24 - Локальная сеть учебного заведения
│
├── 192.168.0.100:8000 - Сервер LMessenger (FastAPI)
│   ├── Процесс: uvicorn main:app
│   ├── Порт: 8000/TCP (HTTP + WebSocket)
│   ├── База данных: messenger.db
│   └── Логи: server.log
│
├── 192.168.0.101 - Клиент 1 (Преподаватель)
│   ├── Приложение: LMessengerClient.exe
│   ├── Конфигурация: config.py
│   └── Временные файлы: %TEMP%
│
├── 192.168.0.102 - Клиент 2 (Студент 1)
│   ├── Приложение: python main.py
│   └── Зависимости: requirements.txt
│
├── 192.168.0.103 - Клиент 3 (Студент 2)
│   └── ...
│
└── 192.168.0.104-199 - Дополнительные клиенты
```

### 2.3. Топологии развертывания

#### 2.3.1. Базовая топология (рекомендуемая)
```
┌─────────────────────────────────────────┐
│         Стандартный компьютерный класс    │
│                                           │
│  ┌──────────┐    ┌──────────┐    ┌─────┐ │
│  │ Сервер   │    │  Проектор │    │ ... │ │
│  │ (Учитель)│    │          │    │     │ │
│  └────┬─────┘    └──────────┘    └─────┘ │
│       │                                   │
│  ┌────┴──────────────────────────────┐   │
│  │        Коммутатор (Switch)        │   │
│  └┬────┬────┬────┬────┬────┬────┬────┘   │
│   │    │    │    │    │    │    │        │
│  ┌┴┐  ┌┴┐  ┌┴┐  ┌┴┐  ┌┴┐  ┌┴┐  ┌┴┐       │
│  │C│  │C│  │C│  │C│  │C│  │C│  │C│       │
│  │1│  │2│  │3│  │4│  │5│  │6│  │7│       │
│  └─┘  └─┘  └─┘  └─┘  └─┘  └─┘  └─┘       │
└─────────────────────────────────────────┘
```

#### 2.3.2. Топология с Wi-Fi
```
┌─────────────────────────────────────────┐
│        Компьютерный класс с Wi-Fi        │
│                                           │
│     ┌──────────────────────────┐         │
│     │      Wi-Fi Router        │         │
│     │  192.168.1.1             │         │
│     └┬──────┬──────┬──────┬────┘         │
│      │      │      │      │              │
│     ┌┴┐    ┌┴┐    ┌┴┐    ┌┴┐             │
│     │S│    │C│    │C│    │C│             │
│     │e│    │1│    │2│    │3│             │
│     │r│    └─┘    └─┘    └─┘             │
│     │v│                                  │
│     │e│   Ноутбуки и мобильные           │
│     │r│   устройства студентов           │
│     └─┘                                  │
└─────────────────────────────────────────┘
```

### 2.4. Требования к развертыванию

#### 2.4.1. Серверные требования
```yaml
server_deployment:
  operating_system: "Windows 10/11 или Linux (Ubuntu 20.04+)"
  python_version: "3.8+"
  dependencies:
    - "fastapi==0.104.1"
    - "uvicorn[standard]==0.24.0"
    - "sqlite3"
    - "python-jose[cryptography]==3.3.0"
    - "passlib[bcrypt]==1.7.4"
    - "websockets==12.0"
  
  network_configuration:
    ip_address: "статический (рекомендуется)"
    port: "8000"
    firewall_rules:
      - "Разрешить входящие на порт 8000"
  
  storage:
    database: "минимум 100 МБ"
    logs: "минимум 50 МБ"
    backups: "рекомендуется 1 ГБ"
  
  startup_script: |
    #!/bin/bash
    cd /opt/lmessenger/server
    source venv/bin/activate
    uvicorn main:app --host 0.0.0.0 --port 8000
```

#### 2.4.2. Клиентские требования
```yaml
client_deployment:
  supported_os: ["Windows 10", "Windows 11", "Ubuntu 20.04+", "Linux Mint"]
  
  installation_methods:
    - "Исполняемый файл (Windows): LMessengerClient.exe"
    - "Python скрипт: python main.py"
    - "Пакетный менеджер: pip install (в разработке)"
  
  configuration:
    config_file: "config.py"
    settings:
      server_host: "192.168.0.100"
      server_port: "8000"
      auto_start: "true"
      notifications: "true"
  
  first_run_setup:
    steps:
      - "Проверка подключения к серверу"
      - "Регистрация или вход"
      - "Настройка параметров"
```

### 2.5. Процедура развертывания

#### 2.5.1. Развертывание сервера
```bash
# Шаг 1: Подготовка системы
sudo apt update && sudo apt upgrade -y  # Для Linux
# или обновление Windows

# Шаг 2: Установка Python
sudo apt install python3 python3-pip python3-venv -y

# Шаг 3: Клонирование проекта
git clone https://github.com/username/local-messenger.git
cd local-messenger/server

# Шаг 4: Создание виртуального окружения
python3 -m venv venv
source venv/bin/activate

# Шаг 5: Установка зависимостей
pip install -r requirements.txt

# Шаг 6: Настройка конфигурации
cp config.example.py config.py
# Редактирование config.py (установка IP)

# Шаг 7: Инициализация базы данных
python -c "from database.db import init_db; init_db()"

# Шаг 8: Запуск сервера
uvicorn main:app --host 0.0.0.0 --port 8000

# Шаг 9: Автозапуск (опционально)
# Для systemd (Linux):
sudo cp lmessenger.service /etc/systemd/system/
sudo systemctl enable lmessenger
sudo systemctl start lmessenger
```

#### 2.5.2. Развертывание клиента
```bash
# Вариант A: Исполняемый файл (Windows)
1. Скачать LMessengerClient.exe
2. Запустить файл
3. Настроить IP сервера при первом запуске

# Вариант B: Python скрипт
1. Установить Python 3.8+
2. Установить зависимости: pip install pyqt5 requests websockets
3. Скачать клиентские файлы
4. Настроить config.py
5. Запустить: python main.py

# Вариант C: Пакетная установка (для класса)
# install_clients.bat (Windows)
@echo off
echo Установка LMessenger для компьютерного класса
xcopy /E /I "\\server\share\lmessenger" "C:\Program Files\LMessenger"
cd "C:\Program Files\LMessenger"
pip install -r requirements.txt
python setup_client.py
echo Установка завершена
```

### 2.6. Мониторинг и обслуживание

#### 2.6.1. Мониторинг сервера
```python
# health_check.py
import requests
import sqlite3
from datetime import datetime

def check_server_health(server_url):
    checks = {
        'api_accessible': False,
        'database_connected': False,
        'websocket_working': False,
        'uptime': None
    }
    
    # Проверка API
    try:
        response = requests.get(f"{server_url}/health", timeout=5)
        checks['api_accessible'] = response.status_code == 200
    except:
        pass
    
    # Проверка базы данных
    try:
        conn = sqlite3.connect('messenger.db')
        cursor = conn.cursor()
        cursor.execute("SELECT COUNT(*) FROM users")
        checks['database_connected'] = True
        conn.close()
    except:
        pass
    
    return checks
```

#### 2.6.2. Логирование
```python
# Настройка логирования
import logging

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('lmessenger.log'),
        logging.StreamHandler()
    ]
)

logger = logging.getLogger(__name__)

# Пример использования
logger.info("Сервер запущен на порту 8000")
logger.warning("Высокая нагрузка на БД")
logger.error("Ошибка подключения к WebSocket")
```

---

## 3. Схема базы данных

### 3.1. ER-диаграмма базы данных

```mermaid
erDiagram
    USERS {
        int id PK "PRIMARY KEY"
        string username UK "UNIQUE"
        string password_hash
        boolean is_online
        datetime last_seen
        string status
        boolean is_admin
        datetime created_at
    }
    
    MESSAGES {
        int id PK "PRIMARY KEY"
        int sender_id FK "FOREIGN KEY"
        int receiver_id FK "FOREIGN KEY"
        string content
        string message_type
        text file_data
        boolean is_read
        datetime timestamp
    }
    
    USERS ||--o{ MESSAGES : sends
    USERS ||--o{ MESSAGES : receives
```

### 3.2. Полная схема базы данных

```sql
-- ============================================
-- Таблица: users (Пользователи)
-- ============================================
CREATE TABLE IF NOT EXISTS users (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    username TEXT UNIQUE NOT NULL,
    password_hash TEXT NOT NULL,
    is_online BOOLEAN DEFAULT FALSE,
    last_seen DATETIME,
    status TEXT DEFAULT 'offline',
    is_admin BOOLEAN DEFAULT FALSE,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    
    -- Проверочные ограничения
    CHECK (LENGTH(username) >= 3 AND LENGTH(username) <= 50),
    CHECK (status IN ('online', 'offline', 'away', 'busy'))
);

-- ============================================
-- Таблица: messages (Сообщения)
-- ============================================
CREATE TABLE IF NOT EXISTS messages (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    sender_id INTEGER NOT NULL,
    receiver_id INTEGER NOT NULL,
    content TEXT NOT NULL,
    message_type TEXT DEFAULT 'text',
    file_data TEXT,
    is_read BOOLEAN DEFAULT FALSE,
    timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
    
    -- Внешние ключи
    FOREIGN KEY (sender_id) REFERENCES users (id) 
        ON DELETE CASCADE,
    FOREIGN KEY (receiver_id) REFERENCES users (id) 
        ON DELETE CASCADE,
    
    -- Проверочные ограничения
    CHECK (message_type IN ('text', 'image', 'file')),
    CHECK (LENGTH(content) <= 2000)
);

-- ============================================
-- Индексы для оптимизации запросов
-- ============================================

-- Для быстрого поиска пользователей
CREATE INDEX IF NOT EXISTS idx_users_username 
ON users(username);

CREATE INDEX IF NOT EXISTS idx_users_online 
ON users(is_online);

-- Для поиска сообщений между пользователями
CREATE INDEX IF NOT EXISTS idx_messages_sender_receiver 
ON messages(sender_id, receiver_id);

CREATE INDEX IF NOT EXISTS idx_messages_receiver_sender 
ON messages(receiver_id, sender_id);

CREATE INDEX IF NOT EXISTS idx_messages_timestamp 
ON messages(timestamp DESC);

-- Для поиска непрочитанных сообщений
CREATE INDEX IF NOT EXISTS idx_messages_unread 
ON messages(receiver_id, is_read) 
WHERE is_read = FALSE;

-- Для поиска по типу сообщения
CREATE INDEX IF NOT EXISTS idx_messages_type 
ON messages(message_type);
```

### 3.3. Описание таблиц

#### 3.3.1. Таблица `users`

| Поле | Тип | Ограничения | Описание |
|------|-----|-------------|----------|
| `id` | INTEGER | PRIMARY KEY AUTOINCREMENT | Уникальный идентификатор пользователя |
| `username` | TEXT | UNIQUE, NOT NULL, LENGTH(3-50) | Имя пользователя (логин) |
| `password_hash` | TEXT | NOT NULL | Хеш пароля (bcrypt) |
| `is_online` | BOOLEAN | DEFAULT FALSE | Флаг онлайн-статуса |
| `last_seen` | DATETIME | NULL | Время последней активности |
| `status` | TEXT | DEFAULT 'offline', CHECK | Статус пользователя |
| `is_admin` | BOOLEAN | DEFAULT FALSE | Флаг администратора |
| `created_at` | DATETIME | DEFAULT CURRENT_TIMESTAMP | Дата регистрации |

**Статусы пользователя:**
- `online` - Пользователь онлайн
- `offline` - Пользователь оффлайн
- `away` - Отошел (планируется)
- `busy` - Занят (планируется)

#### 3.3.2. Таблица `messages`

| Поле | Тип | Ограничения | Описание |
|------|-----|-------------|----------|
| `id` | INTEGER | PRIMARY KEY AUTOINCREMENT | Уникальный идентификатор сообщения |
| `sender_id` | INTEGER | NOT NULL, FOREIGN KEY | ID отправителя |
| `receiver_id` | INTEGER | NOT NULL, FOREIGN KEY | ID получателя |
| `content` | TEXT | NOT NULL, LENGTH(≤2000) | Текст сообщения или описание файла |
| `message_type` | TEXT | DEFAULT 'text', CHECK | Тип сообщения |
| `file_data` | TEXT | NULL | Данные файла в base64 |
| `is_read` | BOOLEAN | DEFAULT FALSE | Флаг прочтения |
| `timestamp` | DATETIME | DEFAULT CURRENT_TIMESTAMP | Время отправки |

**Типы сообщений:**
- `text` - Текстовое сообщение
- `image` - Изображение (PNG, JPG, GIF, BMP)
- `file` - Файл (планируется)

### 3.4. Примеры данных

#### 3.4.1. Пример записи в таблице `users`
```sql
INSERT INTO users (username, password_hash, is_online, status, is_admin) 
VALUES (
    'teacher',
    '$2b$12$LQv3c1yqBWVHx5wRkFq3OeXr9dT8uYzA1B2C3D4E5F6G7H8I9J0K1L',
    TRUE,
    'online',
    TRUE
);
```

#### 3.4.2. Пример записи в таблице `messages`
```sql
-- Текстовое сообщение
INSERT INTO messages (sender_id, receiver_id, content, message_type, is_read) 
VALUES (1, 2, 'Привет! Как дела?', 'text', FALSE);

-- Сообщение с изображением
INSERT INTO messages (sender_id, receiver_id, content, message_type, file_data, is_read) 
VALUES (
    2, 
    1, 
    'File: diagram.png', 
    'image', 
    'iVBORw0KGgoAAAANSUhEUgAA...',  -- base64 данные
    FALSE
);
```

### 3.5. Основные запросы

#### 3.5.1. Получение диалога между двумя пользователями
```sql
SELECT 
    m.*,
    s.username as sender_name,
    r.username as receiver_name
FROM messages m
JOIN users s ON m.sender_id = s.id
JOIN users r ON m.receiver_id = r.id
WHERE (m.sender_id = ? AND m.receiver_id = ?)
   OR (m.sender_id = ? AND m.receiver_id = ?)
ORDER BY m.timestamp DESC
LIMIT 100;
```

#### 3.5.2. Получение непрочитанных сообщений
```sql
SELECT 
    m.*,
    u.username as sender_username
FROM messages m
JOIN users u ON m.sender_id = u.id
WHERE m.receiver_id = ? 
  AND m.is_read = FALSE
ORDER BY m.timestamp;
```

#### 3.5.3. Обновление статуса пользователя
```sql
-- Установка онлайн-статуса
UPDATE users 
SET is_online = TRUE, 
    last_seen = NULL, 
    status = 'online'
WHERE id = ?;

-- Установка оффлайн-статуса
UPDATE users 
SET is_online = FALSE, 
    last_seen = CURRENT_TIMESTAMP, 
    status = 'offline'
WHERE id = ?;
```

#### 3.5.4. Статистика системы
```sql
-- Количество пользователей
SELECT COUNT(*) as total_users FROM users;

-- Количество сообщений
SELECT COUNT(*) as total_messages FROM messages;

-- Количество онлайн пользователей
SELECT COUNT(*) as online_users FROM users WHERE is_online = TRUE;

-- Среднее количество сообщений в день
SELECT 
    DATE(timestamp) as date,
    COUNT(*) as messages_per_day
FROM messages
GROUP BY DATE(timestamp)
ORDER BY date DESC;
```

### 3.6. Миграции базы данных

#### 3.6.1. Создание миграции
```python
# migrations/v1_create_tables.py
def migrate_v1():
    conn = sqlite3.connect('messenger.db')
    cursor = conn.cursor()
    
    # Создание таблицы пользователей
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS users (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            username TEXT UNIQUE NOT NULL,
            password_hash TEXT NOT NULL,
            is_online BOOLEAN DEFAULT FALSE,
            last_seen DATETIME,
            status TEXT DEFAULT 'offline',
            is_admin BOOLEAN DEFAULT FALSE,
            created_at DATETIME DEFAULT CURRENT_TIMESTAMP
        )
    ''')
    
    # Создание таблицы сообщений
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS messages (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            sender_id INTEGER NOT NULL,
            receiver_id INTEGER NOT NULL,
            content TEXT NOT NULL,
            message_type TEXT DEFAULT 'text',
            file_data TEXT,
            is_read BOOLEAN DEFAULT FALSE,
            timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (sender_id) REFERENCES users (id),
            FOREIGN KEY (receiver_id) REFERENCES users (id)
        )
    ''')
    
    conn.commit()
    conn.close()
```

#### 3.6.2. Резервное копирование
```bash
#!/bin/bash
# backup_database.sh
BACKUP_DIR="/var/backups/lmessenger"
DATE=$(date +%Y%m%d_%H%M%S)
BACKUP_FILE="$BACKUP_DIR/messenger_$DATE.db"

# Создание директории для бэкапов
mkdir -p $BACKUP_DIR

# Копирование базы данных
cp messenger.db $BACKUP_FILE

# Сжатие бэкапа
gzip $BACKUP_FILE

# Удаление старых бэкапов (старше 30 дней)
find $BACKUP_DIR -name "*.db.gz" -mtime +30 -delete

echo "Backup created: $BACKUP_FILE.gz"
```

---

## 4. API документация (Swagger/OpenAPI)

### 4.1. Общая информация

**Base URL:** `http://{server_ip}:8000`  
**API Version:** 1.0  
**Схема аутентификации:** Bearer Token (JWT)

### 4.2. OpenAPI спецификация

```yaml
openapi: 3.0.0
info:
  title: Local Messenger API
  description: API для локального мессенджера образовательного учреждения
  version: 1.0.0
  contact:
    name: Малиневский Егор Сергеевич
    group: 21ИС-24

servers:
  - url: http://localhost:8000
    description: Локальный сервер
  - url: http://{server_ip}:8000
    description: Пользовательский сервер

components:
  securitySchemes:
    BearerAuth:
      type: http
      scheme: bearer
      bearerFormat: JWT
  
  schemas:
    UserCreate:
      type: object
      required:
        - username
        - password
      properties:
        username:
          type: string
          example: "student1"
          minLength: 3
          maxLength: 50
        password:
          type: string
          example: "securepassword123"
          minLength: 6
    
    UserLogin:
      type: object
      required:
        - username
        - password
      properties:
        username:
          type: string
          example: "student1"
        password:
          type: string
          example: "securepassword123"
    
    UserResponse:
      type: object
      properties:
        id:
          type: integer
          example: 1
        username:
          type: string
          example: "student1"
        is_online:
          type: boolean
          example: true
        last_seen:
          type: string
          format: date-time
          example: "2024-01-15T10:30:00"
        status:
          type: string
          enum: [online, offline, away, busy]
          example: "online"
        is_admin:
          type: boolean
          example: false
    
    MessageCreate:
      type: object
      required:
        - content
        - receiver_id
      properties:
        content:
          type: string
          example: "Привет! Как дела?"
          maxLength: 2000
        receiver_id:
          type: integer
          example: 2
        message_type:
          type: string
          enum: [text, image, file]
          default: "text"
          example: "text"
        file_data:
          type: string
          description: "Base64 encoded file data"
          example: "iVBORw0KGgoAAAANSUhEUgAA..."
    
    MessageResponse:
      type: object
      properties:
        id:
          type: integer
          example: 123
        sender_id:
          type: integer
          example: 1
        receiver_id:
          type: integer
          example: 2
        content:
          type: string
          example: "Привет! Как дела?"
        timestamp:
          type: string
          format: date-time
          example: "2024-01-15T10:30:00"
        is_read:
          type: boolean
          example: false
        message_type:
          type: string
          example: "text"
        file_data:
          type: string
          nullable: true
    
    ErrorResponse:
      type: object
      properties:
        detail:
          type: string
          example: "Invalid credentials"
```

### 4.3. Endpoints документация

#### 4.3.1. Аутентификация (`/auth/*`)

**POST /auth/register**  
*Регистрация нового пользователя*

```http
POST /auth/register
Content-Type: application/json

{
  "username": "newuser",
  "password": "password123"
}
```

**Responses:**
- `200 OK`: Успешная регистрация
  ```json
  {
    "id": 3,
    "username": "newuser",
    "is_online": true,
    "last_seen": null,
    "status": "online",
    "is_admin": false
  }
  ```
- `400 Bad Request`: Неверные данные
  ```json
  {
    "detail": "Username already exists"
  }
  ```

**POST /auth/login**  
*Вход в систему*

```http
POST /auth/login
Content-Type: application/json

{
  "username": "existinguser",
  "password": "password123"
}
```

**Responses:**
- `200 OK`: Успешный вход
  ```json
  {
    "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "token_type": "bearer"
  }
  ```
- `401 Unauthorized`: Неверные учетные данные
  ```json
  {
    "detail": "Invalid credentials"
  }
  ```

#### 4.3.2. Сообщения (`/messages/*`)

**GET /messages**  
*Получение истории сообщений с контактом*

```http
GET /messages?contact_id=2&limit=100
Authorization: Bearer {token}
```

**Query Parameters:**
- `contact_id` (required): ID пользователя для диалога
- `limit` (optional, default=100): Максимальное количество сообщений

**Responses:**
- `200 OK`: Список сообщений
  ```json
  {
    "messages": [
      {
        "id": 123,
        "sender_id": 1,
        "receiver_id": 2,
        "content": "Привет!",
        "timestamp": "2024-01-15T10:30:00",
        "is_read": true,
        "message_type": "text"
      }
    ],
    "total_count": 1
  }
  ```

**POST /messages**  
*Отправка сообщения*

```http
POST /messages
Authorization: Bearer {token}
Content-Type: application/json

{
  "content": "Новое сообщение",
  "receiver_id": 2,
  "message_type": "text"
}
```

**Для отправки изображения:**
```json
{
  "content": "File: photo.png",
  "receiver_id": 2,
  "message_type": "image",
  "file_data": "iVBORw0KGgoAAAANSUhEUgAA..."
}
```

**Responses:**
- `200 OK`: Сообщение отправлено
  ```json
  {
    "id": 124,
    "sender_id": 1,
    "receiver_id": 2,
    "content": "Новое сообщение",
    "timestamp": "2024-01-15T10:31:00",
    "is_read": false,
    "message_type": "text"
  }
  ```

**DELETE /messages/{message_id}**  
*Удаление сообщения*

```http
DELETE /messages/123
Authorization: Bearer {token}
```

**Responses:**
- `200 OK`: Сообщение удалено
  ```json
  {
    "status": "success",
    "message": "Message deleted",
    "deleted_message_id": 123
  }
  ```
- `403 Forbidden`: Нет прав на удаление
- `404 Not Found`: Сообщение не найдено

**PUT /messages/{message_id}/read**  
*Отметка сообщения как прочитанного*

```http
PUT /messages/123/read
Authorization: Bearer {token}
```

**GET /messages/unread**  
*Получение непрочитанных сообщений*

```http
GET /messages/unread
Authorization: Bearer {token}
```

#### 4.3.3. Пользователи (`/users/*`)

**GET /users**  
*Получение списка всех пользователей*

```http
GET /users
Authorization: Bearer {token}
```

**Responses:**
- `200 OK`: Список пользователей
  ```json
  [
    {
      "id": 1,
      "username": "teacher",
      "is_online": true,
      "last_seen": null,
      "status": "online",
      "is_admin": true
    },
    {
      "id": 2,
      "username": "student1",
      "is_online": false,
      "last_seen": "2024-01-15T09:00:00",
      "status": "offline",
      "is_admin": false
    }
  ]
  ```

**GET /users/me**  
*Получение информации о текущем пользователе*

```http
GET /users/me
Authorization: Bearer {token}
```

**GET /users/{user_id}**  
*Получение информации о конкретном пользователе*

```http
GET /users/2
Authorization: Bearer {token}
```

#### 4.3.4. Администрирование (`/admin/*`)

**GET /admin/all-messages**  
*Получение всех сообщений (только для администраторов)*

```http
GET /admin/all-messages
Authorization: Bearer {token}
```

**GET /admin/all-users**  
*Получение информации о всех пользователях (только для администраторов)*

```http
GET /admin/all-users
Authorization: Bearer {token}
```

#### 4.3.5. WebSocket (`/ws/{user_id}`)

**Endpoint:** `ws://{server_ip}:8000/ws/{user_id}`

**Протокол подключения:**
1. Установка WebSocket соединения
2. Аутентификация через JWT (если требуется)
3. Получение/отправка сообщений в реальном времени

**Формат сообщений:**
```json
// Новое сообщение
{
  "type": "new_message",
  "message": {
    "id": 123,
    "sender_id": 1,
    "receiver_id": 2,
    "content": "Привет!",
    "timestamp": "2024-01-15T10:30:00",
    "message_type": "text"
  }
}

// Удаление сообщения
{
  "type": "message_deleted",
  "message_id": 123,
  "deleted_by": 1,
  "chat_id": "1_2"
}

// Keep-alive
Клиент → Сервер: "ping"
Сервер → Клиент: "pong"
```

### 4.4. Коды ошибок

| Код HTTP | Код ошибки | Описание | Пример |
|----------|------------|----------|---------|
| 400 | `VALIDATION_ERROR` | Ошибка валидации входных данных | Неверный формат JSON |
| 401 | `INVALID_TOKEN` | Невалидный или отсутствующий токен | Токен истек |
| 403 | `ACCESS_DENIED` | Нет прав доступа | Не администратор |
| 404 | `USER_NOT_FOUND` | Пользователь не найден | Неверный user_id |
| 404 | `MESSAGE_NOT_FOUND` | Сообщение не найдено | Неверный message_id |
| 409 | `USERNAME_EXISTS` | Имя пользователя уже существует | Регистрация с существующим именем |
| 422 | `FILE_TOO_LARGE` | Файл слишком большой | > 10 МБ |
| 500 | `INTERNAL_ERROR` | Внутренняя ошибка сервера | Ошибка базы данных |

### 4.5. Примеры использования

#### 4.5.1. Python клиент
```python
import requests
import websocket
import json

class MessengerClient:
    def __init__(self, base_url, token):
        self.base_url = base_url
        self.headers = {"Authorization": f"Bearer {token}"}
    
    def get_messages(self, contact_id, limit=100):
        response = requests.get(
            f"{self.base_url}/messages",
            params={"contact_id": contact_id, "limit": limit},
            headers=self.headers
        )
        return response.json()
    
    def send_message(self, receiver_id, content):
        payload = {
            "content": content,
            "receiver_id": receiver_id,
            "message_type": "text"
        }
        response = requests.post(
            f"{self.base_url}/messages",
            json=payload,
            headers=self.headers
        )
        return response.json()
    
    def connect_websocket(self, user_id, on_message):
        ws_url = f"ws://{self.base_url.replace('http://', '')}/ws/{user_id}"
        ws = websocket.WebSocketApp(
            ws_url,
            on_message=on_message,
            header=[f"Authorization: Bearer {self.token}"]
        )
        ws.run_forever()
```

#### 4.5.2. cURL примеры
```bash
# Регистрация
curl -X POST http://localhost:8000/auth/register \
  -H "Content-Type: application/json" \
  -d '{"username":"testuser","password":"testpass"}'

# Вход
curl -X POST http://localhost:8000/auth/login \
  -H "Content-Type: application/json" \
  -d '{"username":"testuser","password":"testpass"}'

# Получение сообщений (с токеном)
curl -X GET "http://localhost:8000/messages?contact_id=2" \
  -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."

# Отправка сообщения
curl -X POST http://localhost:8000/messages \
  -H "Authorization: Bearer {token}" \
  -H "Content-Type: application/json" \
  -d '{"content":"Привет!","receiver_id":2}'
```

### 4.6. Автоматическая документация

FastAPI автоматически генерирует документацию:

1. **Swagger UI:** `http://{server_ip}:8000/docs`
   - Интерактивная документация
   - Возможность тестирования endpoints
   - Примеры запросов и ответов

2. **ReDoc:** `http://{server_ip}:8000/redoc`
   - Альтернативная документация
   - Более читаемый формат
   - Структурированное представление

3. **OpenAPI схема:** `http://{server_ip}:8000/openapi.json`
   - Машинно-читаемая спецификация
   - Может быть импортирована в Postman, Insomnia и другие инструменты

---

## 5. Заключение

### 5.1. Резюме архитектуры

Локальный мессенджер построен на **клиент-серверной архитектуре** с использованием современных технологий:

1. **Сервер:** FastAPI (Python) с SQLite базой данных
2. **Клиент:** PyQt5 для десктопных приложений
3. **Коммуникация:** HTTP/REST API + WebSocket для real-time обновлений
4. **Безопасность:** JWT аутентификация + bcrypt хеширование

### 5.2. Ключевые особенности архитектуры

✅ **Модульность:** Разделение на слои (UI, Business Logic, Data Access)  
✅ **Масштабируемость:** Возможность добавления новых функций без переписывания кода  
✅ **Поддержка real-time:** WebSocket для мгновенных уведомлений  
✅ **Кроссплатформенность:** Работа на Windows и Linux  
✅ **Простота развертывания:** Минимальные требования к инфраструктуре  

### 5.3. Дальнейшее развитие

Потенциальные направления улучшения архитектуры:

1. **Микросервисная архитектура:** Выделение сервисов аутентификации, сообщений, файлов
2. **Кластеризация:** Поддержка нескольких серверов для балансировки нагрузки
3. **Кэширование:** Redis для кэширования часто запрашиваемых данных
4. **Мониторинг:** Интеграция с Prometheus/Grafana для мониторинга метрик

---

**Версия документа:** 1.0  
**Дата последнего обновления:** 2026  
**Автор:** Малиневский Егор Сергеевич, группа 21ИС-24

*Архитектурная документация является частью учебного проекта "Локальный мессенджер". Все архитектурные решения могут быть изменены по мере развития проекта.*